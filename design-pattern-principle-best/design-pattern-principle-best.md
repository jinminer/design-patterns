# 设计原则

## 概述

<a href="#open-closed">开闭原则</a>

<a href="#dependency-inversion">依赖倒置原则</a>

<a href="#single-responsibility">单一职责原则</a>

<a href="#interface-segregation">接口隔离原则</a>

<a href="law-of-demeter">迪米特法则</a>(最少知道原则)

<a href="#liskov-substitution">里氏替换原则</a>

<a href="">合成复用原则</a>(组合/复用原则)



## <a name="open-closed">开闭原则</a>

* 定义：一个软件实体如类、模块和函数应该对扩展开发，对修改关闭
* 用抽象构建框架，用实现扩展细节，是面向对象中最基础的设计原则
* 优点：提高软件系统的可复用性及可维护性
* 核心思想：面向抽象编程
  * 抽象相对来说是稳定的，实现类依赖于固定的抽象类，通过抽象隔离以后可能会发生的变化
  * 通过实现接口、抽象方法以及类的继承、方法重写等方式应对变化
  * 从业务场景中抽象出业务模型，以及从抽象模型中得出具体的实例
  * 越低层的基础模块变化，影响范围越大；越高层的模块变化，影响范围越小；
* 范例：spring容器提供的控制反转机制
  * spring提供了类扩展机制，将控制权限交给开发者，通过控制反转特性，实现源码的修改
  * 使用配置文件或者注解的方式注入bean，从而修改spring源码中的一些内容，达到对修改关闭，对扩展开放的目的。



## <a name="dependency-inversion">依赖倒置原则</a>

* 定义
  * 高层模块不应该依赖低层模块，二者都应该依赖其抽象
  * 抽象不应该依赖细节，细节应该依赖抽象
  * 针对接口编程，不要针对实现编程
* 面向抽象
  * 低层类接口或抽象方法往往是某一些业务模型的行为抽象，抽象层描述了一系列相似行为的共有能力
  * 接口或者抽象方法的返回值和入参，是某一类业务模型流转完成后的结果以及完成该业务所必须的条件
  * 低层的抽象方法(业务模型)，只关心业务流转结果(方法返回值)和影响业务的因子(方法入参)，并不在乎具体的业务执行过程
  * 低层类将业务的具体实现交由应用层，应用层决定业务什么时候执行、怎样执行
* 优点
  * 可以减少类之间的耦合性，提高系统的稳定性，提高代码的可读性和可维护性，降低修改程序所造成的风险



## <a name="single-responsibility">单一职责原则</a>

* 定义
  * 不要存在多余一个导致类变更的原因
  * 一个类/接口/方法只负责一项职责
  * 程序的设计、开发、运行是一个不断迭代变更的过程，变更是必然的，我们要接收变更
  * 对于业务模型，在开发过程中，如果能够正确的使用单一职责原则，就能很好的避免对其他业务的影响
* 优点
  * 降低类的复杂度、提高类的可读性，提高系统的可维护性、降低变更引起的风险

* 目的
  * 将方法、模块、服务的业务逻辑交给应用层去处理，底层服务提供的职责应该尽可能地单一，出现什么样的业务流程，就用底层服务组合什么样的代码逻辑，把业务逻辑尽可能的放在业务层
  * 保证基础服务、抽象模型的耐用性，底层服务一旦完成定义，那么就应该保持其耐用性(关闭修改、开发扩展)























