# 单一职责原则



####  定义

---

> [**单一职责原则**](https://zh.wikipedia.org/wiki/%E5%8D%95%E4%B8%80%E5%8A%9F%E8%83%BD%E5%8E%9F%E5%88%99) **(SRP: single responsibility principle)** 规定每个类都应该有一个单一的功能，并且该功能由这个类完全封装起来。这个类的所有服务应该严密的和该功能平行(功能平行，意味着没有依赖)。                                                                                                    该术语是由罗伯特·马丁在他的《敏捷软件开发：原则、模式与实践》中给出的。马丁先生把职责(功能)定义为:"**改变的原因**"，并且总结出一个类或者模块应该有且只有一个改变的原因。                                                                                                                  保持一个类专注于单一功能点上的重要原因是:它会使得类更具健壮性。如果一个类承担得职责过多，就等于把这些职责耦合在了一起。一个职责得变化可能会削弱或者抑制这个类完成其他职责得能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。



#### 用例

---

* 图形绘制/几何计算

``` java
/**
 * 矩形公共api
 */
class Rectangle{
    int area;
    //绘制图形
    draw(int area){
        //调用图形绘制api(该api由jdk类库提供)
    }
    //计算面积
    getArea(int length, int width){
        this.area = length * width;
    }
        
}

/**
 * 图形绘制应用
 */
class GraphicalApplication{
    Retangle retangle = new Retangle();
    retangle.draw();//可以绘制图形
    retangle.getArea(int length, int width);//必要的时候需要进行图形面积计算(比如:根据计算得到的图形面积确定绘画区域的大小)
}

/**
 * 几何计算应用
 */
class ComputationalGeometryApplication{
    getArea(int length, int width){};//只能进行矩形面积计算的工作
}
```



#### 问题

---

* 现在我们需要在区域A上绘制一个宽为6长为8的矩形，当图形绘制应用进行工作时，会初始化`Rectangle api` ，先调用`getArea()` 得到需要分配的画图区域大小，再调用`draw()` 绘制图形，进而完成工作。

  * 一个新任务：在区域B上绘制一个宽为6长为8的矩形，这个时候由于之前我们在A区域绘制图形时已经得到了面积这个参数，所以在这里我们只需要调用`draw()` 方法即可。当然对于新给定的`lenght` 和 `width` 再依次调用`getArea()`和`draw()`方法即可

* 当几何计算应用进行工作时，会初始化`Rectangle ` 再调用`getArea()` 完成任务。

  * 那么问题来了：我在初始化`Rectangle ` 类时，不仅初始化了我想要的`getArea()` 方法，同时也会强制的初始化  `draw()` 方法。我们都知道一个图形绘制api是何其的恐怖，初始化这玩意带来的是n多个`.class` 文件额外开销，真的是豆腐缴成肉价钱(方言：用买肉的钱买了豆腐)。而且对于那些内部实现十分复杂，业务调度十分频繁的api来说，这种耦合性的设计无疑是毁灭性的。

* 来讲一个老王(极具个性，负责图形绘制业务)和旺财(做事严谨，负责几何计算业务)的故事：

  * 某天老王接到了一个新需求：由于公司采购的图纸最大只有100，所以产品小姐姐要求图形绘制功能屏蔽100以上的图形绘制，老王很是爽快的答应了，不就改个参数类型么，于是分分钟将`Rectangle api ` 修改为如下实现

  ```java
  /**
   * 矩形公共api
   */
  class Rectangle{
      int area;
      //绘制图形
      draw(int area){
          //调用图形绘制api(该api由jdk类库提供)
      }
      //计算面积
      getArea(int length, int width) throw UnsupportedOperationException{
          this.area = length * width;
          if(this.area > 100){
              log.error("漂亮的产品小姐姐说100以上的不处理。。。")
              throw new UnsupportedOperationException();
          }
      }
          
  }
  
  /**
   * 图形绘制应用
   */
  class GraphicalApplication{
      Retangle retangle = new Retangle();
      retangle.draw();//可以绘制图形
      retangle.getArea(int length, int width);//必要的时候需要进行图形面积计算(比如:根据计算得到的图形面积确定绘画区域的大小)
  }
  
  ```

  ​        进行编译调试没问题后，项目重新上线，老王负责的图形绘制模块确实很好的满足了产品提出的新需求

  * 不难看出当老王修改过代码后，旺财的几何计算应用也受到了影响，有一天当出现100以上的面积计算需求时，他的功能就挂掉了。于是用户投诉，旺财被产品怒怼。"你看，那个人好像一条狗哎。"
  * 这时候读者肯定有很大的疑问，为啥老王新增的面积大小判断不加到`draw()` 方法里，这样就不影响旺财的功能了呀，但是既然设计之初就将这个两个功能放到了一起，那么就很难强制性的约束 `getArea()` 方法的完整性，这正是**妙处所在:程序的迭代开发存在很大地不确定性，而且对于开发者而言往往更容易专注于自己所负责的模块，这种随意开发的现象很容易滋生。特别是基于现实中项目的业务复杂度和超大重量，这种功能耦合粘连的设计，轻微的改动也可能会造成不可估量的后果，牵一发而动全身。** 



#### 优化

---

* 从上面的例子可以看到，`Rectangle ` 类承担了`draw()` 和 `getArea()` 这两个职责，那么如果我们把这两个职责分担到两个类里面呢？

```  java
/**
 * 几何计算类
 */
public class ComputationalGemotryRetangle{
    //面积计算
    public int getArea(int length, int width){
        return length * width;
    }
}

/**
 * 图形绘制类
 */
public class ComputationalGemotryRetangle{
    //图形绘制
    public draw(int area){};
}

```

* 虽然我们说`draw()` 方法依然会依赖于 `getArea()` 方法的计算结果，但是这时候如果让老王再去对自己负责的图形绘制业务做面积限制，从人的心理行为上来推敲的话，让他去再去直接修改 `ComputationalGemotryRetangle.getArea()` 方法的话会稍显艰难(不会舍近求远)，如果这样分析不太明了的话，我们再设想一下，如果 `getArea()` 是一次远程调用呢？(引用此例并不贴切，领会其要义即可)



#### 结论

---

* 马丁先生在描述单一职责原则时，把职责定义为`变化的原因` ，这个定义极为现实。我们说类作为实际业务的抽象，不同的逻辑处理过程承担着不同的职责，一个类承担了多个职责(多个业务处理逻辑)，就意味着涵盖了多个变化因子，引起这个类变化的原因就会有多个。这些可变因子糅杂在一起，使得类变得不可控，所以说**如果多个职责耦合在一起，一个职责的变化很容易削若或抑制这类完成其他职责的能力，** 影响类的维护和正常运转。
* 从资源开销方面来说：在设计之初，如果多个职责由一个类来承担，不同职责相互耦合。在大多数情况下，我们调用单个方法(职责)时，也会强制执行其他方法的初始化工作，特别是对于某些内部构成较为复杂的api而言，这些浪费资源的行为是不可取的。



#### 思考

---

* 前面内容中我们解析了**单一职责原则** 的一些定义，并用简单的伪代码和一些啰里啰唆的文字描述了职责耦合性设计的一些不可取之处。但是在实际开发中，真正的将 **低耦合、高内聚** 的思想融会贯通却并不容易。究其缘由：对于实际的生产业务来说，每个业务逻辑对应的职责与其他职责相互关联和影响是必然的，理论上是互斥的，但是实际上却相互依赖，而且关系紧密，很难有一种明确的规则能将其明确的区分。

* 反例

  * 比如接口签名类的设计，我们可能不会把签名和验签方法分开放到两个不同的类中去。

     ``` java
     class SignNature{
           
        private PrivateKey privKey;
        private PublicKey pubKey;
        
        //签名
        public String sign(PrivateKey privKey, String content){};
        //验签
        public boolean checkSign(PublicKey pubKey, String content){};
         
     }
     ```
  * 在一次api的远程调用过程中，签名和验签工作都需要进行，这个时候就不需要刻意的关注单一职责问题

* 所以又回到开头部分，我们从辨证的角度来看待这些指导原则，在什么时候，选择哪种设计模式，用什么样的指导原则。这些问题其实并不在于我们能把哪一个书本上已经成型的概念生搬硬套到自己的项目以及代码中，而是我们要真切的思考怎样才能最大程度的保证当前业务场景的代码实现的可扩展性、可维护性以及健壮性，先在自己的脑海中形成一定的构思，再去参考先辈们已经总结过的经验，从中汲取我们需要的部分，活学活用。













